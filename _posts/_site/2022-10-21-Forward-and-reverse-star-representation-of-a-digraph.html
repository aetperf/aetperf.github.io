<p>In this Python notebook, we are going to focus on a graph representation of directed graphs : the forward star representation (and its opposite, the reverse star). The motivation here is to access a network topology and associated data efficiently, without using a large amount of memory space. In many shortest path algorithms, one needs to quickly access the outgoing or incoming edges of the graph vertices, as well as the associated edge attributes. This is why the data structure used to represent the graph is very important regarding the efficiency of graph algorithms. Note that we only consider static graphs here, where the topology does not change.</p>

<h2 id="definitions">Definitions</h2>

<p>From <a href="https://en.wikipedia.org/wiki/Directed_graph">wikipedia</a>:</p>
<blockquote>
  <p>a <strong>directed graph</strong> (or digraph) is a graph that is made up of a set of vertices connected by directed edges, often called arcs.</p>
</blockquote>

<p align="center">
<img width="150" alt="Directed graph no background" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Directed_graph_no_background.svg/128px-Directed_graph_no_background.svg.png" />
</p>

<p><em>Credit:</em> <a href="https://commons.wikimedia.org/wiki/File:Directed_graph_no_background.svg">Wikimedia Commons</a></p>

<p>Here we indifferently use the terms <em>edge</em>, <em>arc</em> or <em>link</em>. Same thing with <em>node</em> or <em>vertex</em>. Also, we denote the two nodes of an arc as <em>head</em> and <em>tail</em> nodes, or <em>target</em> and <em>source</em> nodes, or <em>from node</em> and <em>to node</em>.</p>

<p>Let’s denote the directed graph $\mathcal{G} = \left( V, E \right) $, where $V$ and $E$ are the graph vertices and edges. The head vertices of the <strong>outgoing edges</strong> of vertex $v_i$:</p>

\[E_i^+ = \left\{ j \in V \; s.t. \; (i,j)\in E\right\}\]

<p>The tail vertices of the <strong>incoming edges</strong> of vertex $v_j$:</p>

\[E_j^- = \left\{ i \in V \; s.t. \; (i,j)\in E\right\}\]

<p>In the small example above, the incoming edges of vertex 3 are : (1, 3) and (4, 3). Its outgoing edges are : (3, 2) and (3, 4).</p>

<h2 id="imports">Imports</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="kn">import</span> <span class="n">networkx</span> <span class="k">as</span> <span class="n">nx</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">from</span> <span class="n">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_array</span><span class="p">,</span> <span class="n">csc_matrix</span><span class="p">,</span> <span class="n">csr_matrix</span>
</code></pre></div></div>

<h2 id="a-small-toy-network">A Small toy network</h2>

<p>In order to describe the topology of a graph, we just need the edge table with tail node index, head node index and edge attributes. Here we use a Pandas <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">dataframe</a> to store this table. Let’s take the small example from <em>Sheffi</em> [1] with 10 edges:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tail_verts</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">head_verts</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">edge_weights</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">edges_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span>
    <span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">:</span> <span class="n">tail_verts</span><span class="p">,</span> <span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">:</span> <span class="n">head_verts</span><span class="p">,</span> <span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">:</span> <span class="n">edge_weights</span><span class="p">}</span>
<span class="p">)</span>
<span class="n">edges_df</span><span class="p">.</span><span class="nf">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></div>

<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>from_node</th>
      <th>to_node</th>
      <th>weight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>4</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>4</td>
      <td>2.0</td>
    </tr>
  </tbody>
</table>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vertex_count</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">]].</span><span class="nf">max</span><span class="p">().</span><span class="nf">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">edge_count</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">edges_df</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">vertex count : </span><span class="si">{</span><span class="n">vertex_count</span><span class="si">}</span><span class="s">,  edge count : </span><span class="si">{</span><span class="n">edge_count</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vertex count : 6,  edge count : 10
</code></pre></div></div>

<p>Note that this network only has only a single attribute per edge, <code class="language-plaintext highlighter-rouge">weight</code>, which is of <code class="language-plaintext highlighter-rouge">float64</code> type. The node indices are of <code class="language-plaintext highlighter-rouge">uint32</code> type, which is allowing us to deal with more than 4 billion nodes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="nf">iinfo</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iinfo(min=0, max=4294967295, dtype=uint32)
</code></pre></div></div>

<p>We can load this network into <a href="https://networkx.org/">NetworkX</a> in order to plot it, in the following way:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nf">from_pandas_edgelist</span><span class="p">(</span>
    <span class="n">edges_df</span><span class="p">,</span>
    <span class="n">source</span><span class="o">=</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">target</span><span class="o">=</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">edge_attr</span><span class="o">=</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">create_using</span><span class="o">=</span><span class="n">nx</span><span class="p">.</span><span class="n">DiGraph</span><span class="p">,</span>
<span class="p">)</span>
<span class="nf">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>networkx.classes.digraph.DiGraph
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pos</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="mi">1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="mi">2</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="mi">3</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="mi">4</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="mi">5</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">}</span>  <span class="c1"># here we assign some coordinates to each vertex
</span><span class="n">nx</span><span class="p">.</span><span class="nf">draw_networkx</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">pos</span><span class="p">,</span>
    <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">node_color</span><span class="o">=</span><span class="sh">"</span><span class="s">#F1EAE8</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">node_size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>
    <span class="n">font_family</span><span class="o">=</span><span class="sh">"</span><span class="s">ubuntu</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">connectionstyle</span><span class="o">=</span><span class="sh">"</span><span class="s">arc3,rad=-0.025</span><span class="sh">"</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nf">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">nx</span><span class="p">.</span><span class="nf">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span> <span class="n">label_pos</span><span class="o">=</span><span class="mf">0.45</span><span class="p">)</span>
</code></pre></div></div>

<p align="center">
  <img width="800" src="/img/2022-10-21_01/output_11_0.png" alt="networkx" />
</p>

<h2 id="sparse-matrix-formats">Sparse matrix formats</h2>

<p>We can represent the graph as a <strong>Node-Node Adjacency Matrix</strong> with a sparse format.</p>

<p>Let’s start by describing the Node-Node Adjacency Matrix. If the graph does not have any parallel edge, it can be expressed as a (<code class="language-plaintext highlighter-rouge">vertex_count</code> x <code class="language-plaintext highlighter-rouge">vertex_count</code>) matrix, where rows correspond to tail nodes and columns to head nodes. The (i, j)-th entry equals 1 if $(i, j) \in E$, and 0 otherwise.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">vertex_count</span><span class="p">,</span> <span class="n">vertex_count</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">M</span><span class="p">[</span><span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span><span class="p">,</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">M</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([[0, 1, 0, 1, 1, 0],
       [0, 0, 1, 0, 1, 1],
       [0, 0, 0, 0, 0, 1],
       [0, 0, 0, 0, 1, 0],
       [0, 1, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0]], dtype=uint32)
</code></pre></div></div>

<p>Because this kind of matrix has a lot of zeros when dealing with sparse graphs, we only store the non-zero entries. The most simple sparse storage format is the COO matrix format, that we are going to see in the next sub-section.</p>

<p>Because we want to access some edge attributes, we do not store an array of ones as non-zeros, as it is described just above. Instead, we store the attributes. In the present example, the data vector is 1D as there is only a single edge attribute: <code class="language-plaintext highlighter-rouge">weight</code>. So here is the actual matrix that we want to represent with a sparse format:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">vertex_count</span><span class="p">,</span> <span class="n">vertex_count</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">M</span><span class="p">[</span><span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span><span class="p">,</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
<span class="n">M</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([[0., 6., 0., 3., 2., 0.],
       [0., 0., 2., 0., 2., 1.],
       [0., 0., 0., 0., 0., 3.],
       [0., 0., 0., 0., 1., 0.],
       [0., 3., 0., 0., 0., 5.],
       [0., 0., 0., 0., 0., 0.]])
</code></pre></div></div>

<h3 id="coo-format">COO format</h3>

<p>Coordinate list (COO) stores a list of (row, column, value) tuples. It is also know as <em>triplet</em> format. Here, we access to the COO data column-wise:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">coo_row</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
<span class="n">coo_col</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
<span class="n">coo_val</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
</code></pre></div></div>

<p>Let’s create a SciPy sparse matrix in COOrdinate format with <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html"><code class="language-plaintext highlighter-rouge">scipy.sparse.coo_matrix</code></a> in order to check our computations later .</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sp_coo</span> <span class="o">=</span> <span class="nf">coo_array</span><span class="p">(</span>
    <span class="p">(</span><span class="n">coo_val</span><span class="p">,</span> <span class="p">(</span><span class="n">coo_row</span><span class="p">,</span> <span class="n">coo_col</span><span class="p">)),</span>
    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">vertex_count</span><span class="p">,</span> <span class="n">vertex_count</span><span class="p">),</span>
<span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">coo_row</span><span class="p">,</span> <span class="n">sp_coo</span><span class="p">.</span><span class="n">row</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">coo_col</span><span class="p">,</span> <span class="n">sp_coo</span><span class="p">.</span><span class="n">col</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">coo_val</span><span class="p">,</span> <span class="n">sp_coo</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
<span class="nf">type</span><span class="p">(</span><span class="n">sp_coo</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scipy.sparse._arrays.coo_array
</code></pre></div></div>

<p>Now we are going to use another very common sparse format, called <em>Compressed Sparse Row (CSR)</em> or <em>Compressed Row Storage (CRS)</em>. This storage it directly related to the forward star representation of a graph.</p>

<h2 id="csr-format">CSR format</h2>

<p>Here is a detailed description from <a href="https://netlib.org/linalg/html_templates/node91.html">netlib</a>:</p>

<blockquote>
  <p>The Compressed Row and Column Storage formats are the most general: they make absolutely no assumptions about the sparsity structure of the matrix, and they don’t store any unnecessary elements. On the other hand, they are not very efficient, needing an indirect addressing step for every single scalar operation in a matrix-vector product or preconditioner solve.</p>
</blockquote>

<blockquote>
  <p>The Compressed Row Storage (CRS) format puts the subsequent nonzeros of the matrix rows in contiguous memory locations. Assuming we have a nonsymmetric sparse matrix, we create vectors: one for floating-point numbers (<code class="language-plaintext highlighter-rouge">val</code>), and the other two for integers (<code class="language-plaintext highlighter-rouge">col_ind</code>, <code class="language-plaintext highlighter-rouge">row_ptr</code>). The <code class="language-plaintext highlighter-rouge">val</code> vector stores the values of the nonzero elements of the matrix, as they are traversed in a row-wise fashion. The <code class="language-plaintext highlighter-rouge">col_ind</code> vector stores the column indexes of the elements in the <code class="language-plaintext highlighter-rouge">val</code> vector.</p>
</blockquote>

<blockquote>
  <p>That is, if <code class="language-plaintext highlighter-rouge">val[k] = a[i,j]</code> then <code class="language-plaintext highlighter-rouge">col_ind[k]=j</code>. The <code class="language-plaintext highlighter-rouge">row_ptr</code> vector stores the locations in the <code class="language-plaintext highlighter-rouge">val</code> vector that start a row, that is, if <code class="language-plaintext highlighter-rouge">val[k] = a[i,j]</code> then <code class="language-plaintext highlighter-rouge">row_ptr[i] &lt;= k &lt;= row_ptr[i+1]</code>. By convention, we define <code class="language-plaintext highlighter-rouge">row_ptr[n+1] = nnz + 1</code>, where <code class="language-plaintext highlighter-rouge">nnz</code> is the number of nonzeros in the matrix <code class="language-plaintext highlighter-rouge">A</code>. The storage savings for this approach is significant. Instead of storing <code class="language-plaintext highlighter-rouge">n²</code> elements, we need only <code class="language-plaintext highlighter-rouge">2 nnz + n + 1</code> storage locations.</p>
</blockquote>

<p>Let’s see how to convert from COO to CSR sparse formats in Python.</p>

<h3 id="convert-coo-to-crs">Convert COO to CRS</h3>

<p>One requirement is that the edge list in COO format must be sorted in an ascending way by the tail node index. In the following, we also sort secondly by the head node index in order to match the result from the <code class="language-plaintext highlighter-rouge">SciPy.sparse</code> library, however this is not required. This implies that for each vertex, the resulting list of outgoing edges will also be sorted, by the head vertex index.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">edges_df</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">coo_row</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
<span class="n">coo_col</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
<span class="n">coo_val</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
</code></pre></div></div>

<p>We start by creating the NumPy arrays for storing the CSR representation. <code class="language-plaintext highlighter-rouge">vertex_count</code> is the dimension of the matrix, while <code class="language-plaintext highlighter-rouge">edge_count</code> is the number of non-zero elements, resulting to <code class="language-plaintext highlighter-rouge">2 edge_count + vertex_count + 1</code> storage locations, as seen above:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csr_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">vertex_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">csr_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">edge_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">csr_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">edge_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">edge_count</span><span class="p">):</span>
    <span class="n">csr_indptr</span><span class="p">[</span><span class="n">coo_row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">csr_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coo_col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">csr_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coo_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">csr_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">cumsum</span><span class="p">(</span><span class="n">csr_indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
</code></pre></div></div>

<p>Check against SciPy:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sp_csr</span> <span class="o">=</span> <span class="n">sp_coo</span><span class="p">.</span><span class="nf">tocsr</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">csr_indptr</span><span class="p">,</span> <span class="n">sp_csr</span><span class="p">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">csr_indices</span><span class="p">,</span> <span class="n">sp_csr</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">csr_data</span><span class="p">,</span> <span class="n">sp_csr</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csr_indptr</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([ 0,  3,  6,  7,  8, 10, 10], dtype=uint32)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csr_indices</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([1, 3, 4, 2, 4, 5, 5, 4, 1, 5], dtype=uint32)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csr_data</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([6., 3., 2., 2., 2., 1., 3., 1., 3., 5.])
</code></pre></div></div>

<p>Here is a schema inspired from <em>Sheffi</em> [1] to understand the general idea regarding the weighted graph in CSR format. The edge attributes (<code class="language-plaintext highlighter-rouge">to_node</code> and <code class="language-plaintext highlighter-rouge">weight</code>) are stored in arrays of size <code class="language-plaintext highlighter-rouge">edge_count</code>. For a given vertex <code class="language-plaintext highlighter-rouge">from_node</code>, the outgoing edges can be found from rank <code class="language-plaintext highlighter-rouge">indptr[from_node]</code> to <code class="language-plaintext highlighter-rouge">indptr[from_node+1]-1</code> (included), if the latter is larger or equal to the former. If <code class="language-plaintext highlighter-rouge">indptr[from_node] == indptr[from_node+1]</code>, there is no outgoing edge.</p>

<p align="center">
  <img width="400" src="/img/2022-10-21_01/CSR.png" alt="CSR schema" />
</p>

<p>For a vertex <code class="language-plaintext highlighter-rouge">tail_vert_idx</code>, the head nodes of the outgoing edges are given by <code class="language-plaintext highlighter-rouge">csr_indices[csr_indptr[tail_vert_idx]:csr_indptr[tail_vert_idx + 1]]</code>, and the associated attribute values by <code class="language-plaintext highlighter-rouge">csr_data[csr_indptr[tail_vert_idx]:csr_indptr[tail_vert_idx + 1]]</code>. For example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tail_vert_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nf">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="sh">"</span><span class="s">head nodes: </span><span class="si">{</span><span class="n">csr_indices</span><span class="p">[</span><span class="n">csr_indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span><span class="p">]</span><span class="si">:</span><span class="n">csr_indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="sh">"</span>
<span class="p">)</span>
<span class="nf">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="sh">"</span><span class="s">edge weights: </span><span class="si">{</span><span class="n">csr_data</span><span class="p">[</span><span class="n">csr_indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span><span class="p">]</span><span class="si">:</span><span class="n">csr_indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="sh">"</span>
<span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head nodes: [1 3 4]
edge weights: [6. 3. 2.]
</code></pre></div></div>

<p>It is also easy to loop over all the vertices and get the associated outgoing edges:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">tail_vert_idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">vertex_count</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">indptr</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">csr_indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span><span class="p">],</span> <span class="n">csr_indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="n">head_vert_idx</span> <span class="o">=</span> <span class="n">csr_indices</span><span class="p">[</span><span class="n">indptr</span><span class="p">]</span>
        <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">csr_data</span><span class="p">[</span><span class="n">indptr</span><span class="p">]</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">(</span><span class="si">{</span><span class="n">tail_vert_idx</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">head_vert_idx</span><span class="si">}</span><span class="s">) : </span><span class="si">{</span><span class="n">edge_weight</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0,1) : 6.0
(0,3) : 3.0
(0,4) : 2.0
(1,2) : 2.0
(1,4) : 2.0
(1,5) : 1.0
(2,5) : 3.0
(3,4) : 1.0
(4,1) : 3.0
(4,5) : 5.0
</code></pre></div></div>

<p>Next we are going to look at the <em>Compressed Sparse Column (CSC)</em> or <em>Compressed Column Storage (CCS)</em>. This storage it directly related to the reverse star representation of a graph.</p>

<h2 id="csc-format">CSC format</h2>

<p>Here is the description from <a href="https://netlib.org/linalg/html_templates/node92.html">netlib</a>:</p>

<blockquote>
  <p>Analogous to Compressed Row Storage there is Compressed Column Storage (CCS), which is also called the Harwell-Boeing sparse matrix format. The CCS format is identical to the CRS format except that the columns of <code class="language-plaintext highlighter-rouge">A</code> are stored (traversed) instead of the rows. In other words, the CCS format is the CRS format for <code class="language-plaintext highlighter-rouge">A.T</code>.</p>
</blockquote>

<blockquote>
  <p>The CCS format is specified by the 3 arrays {<code class="language-plaintext highlighter-rouge">val</code>, <code class="language-plaintext highlighter-rouge">row_ind</code>, <code class="language-plaintext highlighter-rouge">col_ptr</code>}, where <code class="language-plaintext highlighter-rouge">row_ind</code> stores the row indices of each nonzero, and <code class="language-plaintext highlighter-rouge">col_ptr</code> stores the index of the elements in <code class="language-plaintext highlighter-rouge">val</code> which start a column of <code class="language-plaintext highlighter-rouge">A</code>.</p>
</blockquote>

<p>This time, the requirement is that the edge list in COO format must be sorted in an ascending way by the <strong>head</strong> node index.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">edges_df</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">coo_row</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
<span class="n">coo_col</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
<span class="n">coo_val</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="sh">"</span><span class="s">weight</span><span class="sh">"</span><span class="p">].</span><span class="n">values</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csc_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">vertex_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">csc_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">edge_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">csc_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">edge_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">edge_count</span><span class="p">):</span>
    <span class="n">csc_indptr</span><span class="p">[</span><span class="n">coo_col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">csc_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coo_row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">csc_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coo_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">csc_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">cumsum</span><span class="p">(</span><span class="n">csc_indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
</code></pre></div></div>

<p>Check against SciPy:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sp_csc</span> <span class="o">=</span> <span class="n">sp_coo</span><span class="p">.</span><span class="nf">tocsc</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">csc_indptr</span><span class="p">,</span> <span class="n">sp_csc</span><span class="p">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">csc_indices</span><span class="p">,</span> <span class="n">sp_csc</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">csc_data</span><span class="p">,</span> <span class="n">sp_csc</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csc_indptr</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([ 0,  0,  2,  3,  4,  7, 10], dtype=uint32)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csc_indices</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0, 4, 1, 0, 0, 1, 3, 1, 2, 4], dtype=uint32)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csc_data</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([6., 3., 2., 3., 2., 2., 1., 1., 3., 5.])
</code></pre></div></div>

<p>With this CSC format, it is easy to get the incoming edges of a given vertex. For a vertex <code class="language-plaintext highlighter-rouge">head_vert_idx</code>, the tail nodes of the incoming edges are given by <code class="language-plaintext highlighter-rouge">csc_indices[csc_indptr[head_vert_idx]:csc_indptr[head_vert_idx + 1]]</code>, and the associated attribute values by <code class="language-plaintext highlighter-rouge">csc_data[csr_indptr[head_vert_idx]:csr_indptr[head_vert_idx + 1]]</code>. For example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head_vert_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nf">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="sh">"</span><span class="s">tail nodes: </span><span class="si">{</span><span class="n">csc_indices</span><span class="p">[</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span><span class="p">]</span><span class="si">:</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="sh">"</span>
<span class="p">)</span>
<span class="nf">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="sh">"</span><span class="s">edge weights: </span><span class="si">{</span><span class="n">csc_data</span><span class="p">[</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span><span class="p">]</span><span class="si">:</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="sh">"</span>
<span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tail nodes: []
edge weights: []
</code></pre></div></div>

<p>This vertex has no incoming edge. We can try another one:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head_vert_idx</span> <span class="o">=</span> <span class="mi">4</span>
<span class="nf">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="sh">"</span><span class="s">tail nodes: </span><span class="si">{</span><span class="n">csc_indices</span><span class="p">[</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span><span class="p">]</span><span class="si">:</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="sh">"</span>
<span class="p">)</span>
<span class="nf">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="sh">"</span><span class="s">edge weights: </span><span class="si">{</span><span class="n">csc_data</span><span class="p">[</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span><span class="p">]</span><span class="si">:</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="sh">"</span>
<span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tail nodes: [0 1 3]
edge weights: [2. 2. 1.]
</code></pre></div></div>

<p>Let’s loop over all the vertices and get the associated incoming edges:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">head_vert_idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">vertex_count</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">indptr</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span><span class="p">],</span> <span class="n">csc_indptr</span><span class="p">[</span><span class="n">head_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="n">tail_vert_idx</span> <span class="o">=</span> <span class="n">csc_indices</span><span class="p">[</span><span class="n">indptr</span><span class="p">]</span>
        <span class="n">edge_weight</span> <span class="o">=</span> <span class="n">csc_data</span><span class="p">[</span><span class="n">indptr</span><span class="p">]</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">(</span><span class="si">{</span><span class="n">tail_vert_idx</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">head_vert_idx</span><span class="si">}</span><span class="s">) : </span><span class="si">{</span><span class="n">edge_weight</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0,1) : 6.0
(4,1) : 3.0
(1,2) : 2.0
(0,3) : 3.0
(0,4) : 2.0
(1,4) : 2.0
(3,4) : 1.0
(1,5) : 1.0
(2,5) : 3.0
(4,5) : 5.0
</code></pre></div></div>

<h2 id="forward-star-and-reverse-star">Forward star and reverse star</h2>

<p>So what do we call forward and reverse star exactly? Well this a generalization of the CSR and CSC format, with a pointer vector <code class="language-plaintext highlighter-rouge">indptr</code> of size <code class="language-plaintext highlighter-rouge">(vertex_count + 1, 1)</code> and an edge array of size <code class="language-plaintext highlighter-rouge">(edge_count, n_att)</code>, where <code class="language-plaintext highlighter-rouge">n_att</code> is the number of edge attributes that we need to store. Note that we can store the head and tail indices in this array as edge attributes. In the case of forward star, <code class="language-plaintext highlighter-rouge">indptr</code> is pointing toward the outgoing edges, and in the case of the reverse star, toward the incoming edges. Here is a figure with a small example of a forward star (where the pointer vector is named <code class="language-plaintext highlighter-rouge">point</code>):</p>

<p align="center">
  <img width="800" src="/img/2022-10-21_01/forward_star_example.jpg" alt="forward_star_example" />
</p>

<p><em>Credit:</em> these <a href="http://webpages.iust.ac.ir/yaghini/Courses/Network_891/01_3_Representations.pdf">slides</a> online. I guess that this comes from a book?</p>

<p>Because we are not dealing anymore with sparse matrices but directly with edges in triplet form, we can now handle parallel edges. Indeed, a 2D matrix can only have a single entry for a given row and column, but when the edge information is “unpivoted” in a triplet form, we can actually deal with duplicated entries with respect to head and tail nodes, and as many attributes as we want.</p>

<p>Let’s implement a function that converts an edge dataframe into a forward star object. The edge attributes are all assumed to be of <code class="language-plaintext highlighter-rouge">float64</code> type. We would also like to store the head vertex indices in the edge array, but in NumPy, it is kind of complicated to handles 2D arrays with mixed column types (<code class="language-plaintext highlighter-rouge">uint32</code> and <code class="language-plaintext highlighter-rouge">float64</code>). So here, we basically have an array of edge attributes with integer type (<code class="language-plaintext highlighter-rouge">indices</code>), and another one with the ones of <code class="language-plaintext highlighter-rouge">float</code> type. A C implementation could make use of some <code class="language-plaintext highlighter-rouge">struct</code>.</p>

<h3 id="edges-dataframe-to-forward-star">Edges dataframe to forward star</h3>

<p>We assume that all the edge attributes are of <code class="language-plaintext highlighter-rouge">float</code> type.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">edges_to_FS</span><span class="p">(</span><span class="n">edges_df</span><span class="p">,</span> <span class="n">from_node</span><span class="o">=</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">,</span> <span class="n">to_node</span><span class="o">=</span><span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">):</span>

    <span class="n">edges_df</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">vertex_count</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[[</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">]].</span><span class="nf">max</span><span class="p">().</span><span class="nf">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">edge_count</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">edges_df</span><span class="p">)</span>

    <span class="n">attribute_count</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="n">attribute_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">edges_df</span><span class="p">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">]]</span>

    <span class="n">from_node</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="n">from_node</span><span class="p">].</span><span class="n">values</span>
    <span class="n">to_node</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="n">to_node</span><span class="p">].</span><span class="n">values</span>
    <span class="n">edge_val</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="n">attribute_names</span><span class="p">].</span><span class="n">values</span>

    <span class="n">csr_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">vertex_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">csr_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">edge_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">csr_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">edge_count</span><span class="p">,</span> <span class="n">attribute_count</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">edge_count</span><span class="p">):</span>
        <span class="n">csr_indptr</span><span class="p">[</span><span class="n">from_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">csr_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_node</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">csr_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">csr_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">cumsum</span><span class="p">(</span><span class="n">csr_indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>

    <span class="n">names</span> <span class="o">=</span> <span class="sh">"</span><span class="s">,</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">attribute_names</span><span class="p">)</span>
    <span class="n">csr_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">records</span><span class="p">.</span><span class="nf">fromarrays</span><span class="p">(</span><span class="n">csr_data</span><span class="p">.</span><span class="n">T</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

    <span class="n">FS</span> <span class="o">=</span> <span class="nf">namedtuple</span><span class="p">(</span><span class="sh">"</span><span class="s">FS</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">indptr</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">indices</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">data</span><span class="sh">"</span><span class="p">])</span>
    <span class="k">return</span> <span class="nc">FS</span><span class="p">(</span><span class="n">csr_indptr</span><span class="p">,</span> <span class="n">csr_indices</span><span class="p">,</span> <span class="n">csr_data</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FS</span> <span class="o">=</span> <span class="nf">edges_to_FS</span><span class="p">(</span><span class="n">edges_df</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FS</span><span class="p">.</span><span class="n">indptr</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([ 0,  3,  6,  7,  8, 10, 10], dtype=uint32)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FS</span><span class="p">.</span><span class="n">indices</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([1, 3, 4, 2, 4, 5, 5, 4, 1, 5], dtype=uint32)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FS</span><span class="p">.</span><span class="n">data</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rec.array([(6.,), (3.,), (2.,), (2.,), (2.,), (1.,), (3.,), (1.,), (3.,),
           (5.,)],
          dtype=[('weight', '&lt;f8')])
</code></pre></div></div>

<p>Let’s finish with a small example, with some kind of special features.</p>

<h2 id="example-with-parallel-edges-a-loop-an-isolated-vertex-and-several-edge-attributes">Example with parallel edges, a loop, an isolated vertex and several edge attributes</h2>

<p align="center">
  <img width="300" src="/img/2022-10-21_01/small_graph.jpg" alt="query_1" />
</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tail_verts</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">head_verts</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">edge_a1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">edge_a2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">edge_a3</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">edges_df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span>
    <span class="n">data</span><span class="o">=</span><span class="p">{</span>
        <span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">:</span> <span class="n">tail_verts</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">:</span> <span class="n">head_verts</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">a_1</span><span class="sh">"</span><span class="p">:</span> <span class="n">edge_a1</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">a_2</span><span class="sh">"</span><span class="p">:</span> <span class="n">edge_a2</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">a_3</span><span class="sh">"</span><span class="p">:</span> <span class="n">edge_a3</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="n">edges_df</span><span class="p">.</span><span class="nf">head</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>from_node</th>
      <th>to_node</th>
      <th>a_1</th>
      <th>a_2</th>
      <th>a_3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2.0</td>
      <td>3.0</td>
      <td>0.1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>1.0</td>
      <td>2.0</td>
      <td>0.6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>3</td>
      <td>2.0</td>
      <td>8.0</td>
      <td>0.4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>3</td>
      <td>3.0</td>
      <td>9.0</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vertex_count</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[[</span><span class="sh">"</span><span class="s">from_node</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">to_node</span><span class="sh">"</span><span class="p">]].</span><span class="nf">max</span><span class="p">().</span><span class="nf">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">edge_count</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">edges_df</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">vertex count : </span><span class="si">{</span><span class="n">vertex_count</span><span class="si">}</span><span class="s">,  edge count : </span><span class="si">{</span><span class="n">edge_count</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vertex count : 4,  edge count : 4
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fs</span> <span class="o">=</span> <span class="nf">edges_to_FS</span><span class="p">(</span><span class="n">edges_df</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">tail_vert_idx</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">vertex_count</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">indptr</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">fs</span><span class="p">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span><span class="p">],</span> <span class="n">fs</span><span class="p">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">tail_vert_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
        <span class="n">head_vert_idx</span> <span class="o">=</span> <span class="n">fs</span><span class="p">.</span><span class="n">indices</span><span class="p">[</span><span class="n">indptr</span><span class="p">]</span>
        <span class="n">edge_data</span> <span class="o">=</span> <span class="n">fs</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">indptr</span><span class="p">]</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">(</span><span class="si">{</span><span class="n">tail_vert_idx</span><span class="si">}</span><span class="s">,</span><span class="si">{</span><span class="n">head_vert_idx</span><span class="si">}</span><span class="s">) : </span><span class="si">{</span><span class="n">edge_data</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0,1) : (2., 3., 0.1)
(0,1) : (1., 2., 0.6)
(1,3) : (2., 8., 0.4)
(3,3) : (3., 9., 0.)
</code></pre></div></div>

<p>Everything seems to be OK.</p>

<p>In another post, we will see how to implement the forward and reverse stars efficiently in Cython and compare this data structure with another one.</p>

<h2 id="references">References</h2>

<p>[1] Y. Sheffi, <em>“Urban Transportation Networks: Equilibrium Analysis with Mathematical Programming Methods,”</em> Prentice-Hall, Englewoods Cliffs, 1985.</p>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://aetperf-github-io-1.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

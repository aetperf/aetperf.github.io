<p align="center">
  <img width="300" src="/img/2022-11-23_01/abstract_data_structure.jpg" alt="abstract_data_structure" />
</p>
<center><b>Credit:</b> <i>Musée de l'illusion, Lyon (picture taken by myself)</i></center>

<p><br />
<br />
In this post, we describe a basic Cython implementation of a <em>priority queue</em>.</p>

<p>A priority queue is an important data structure in computer science with many applications. In the present post, our motivation is to write a priority queue for classic shortest path algorithms, such as Dijkstra’s Single Source Shortest Path (SSSP). We target rather sparse graphs, such as transportation networks.</p>

<h2 id="the-priority-queue-operations">The Priority queue operations</h2>

<p>For that kind of algorithms, we have a fixed set of elements, usually either the graph vertices or edges, each associated with a <em>key</em> real number. This key value may represent a travel time from an origin, for example. The purpose of the priority queue is to be able to extract the element from the queue with minimum priority key. Also, we need to be able to insert some elements with a given key into the queue, and to decrease the key of an element from the queue. This happens for example in SSSP when a shorter path to a vertex is found.</p>

<p>As described by Chen in [1]:</p>

<blockquote>
  <p>A <em>priority queue</em> is a collection of elements each with a numerical <em>priority</em>, also known as its <em>key</em>. Priority queues support <em>insert</em>, <em>extract-min</em> operations. An insert operation adds one element and its key into the priority queue. A call to extract-min deletes the element with the lowest key from the queue, and returns the element with its key. <br />
Optionally, a priority queue may support <em>delete</em> and <em>decrease-key</em> operation. The decrease-key operation takes as its parameters an element reference, and a new key. The result is that if the element is present in the priority queue, its current key is replaced with the new key. To implement delete and decrease-key operations efficiently, a priority queue must be able to access specific elements in constant time. Usually this is done by keeping a table of element pointers.</p>
</blockquote>

<p>In the present case, we are going to implement the decrease-key operation, not the delete one. So we are going to need a table of “element pointers”, which implies some kind of heavy mechanism. However, we are only going to deal with indices and not direct memory location addresses. This will be described in a following section. Note that it is possible to implement the SSSP algorithm without the decrease-key operation in the priority queue, but we need this operation for other algorithms than SSSP.</p>

<p>To summarize, we are going to build a data structure for maintaining a set $S$ of elements, each with an associated value called a key, and supporting the following operations:</p>
<ul>
  <li><em>INSERT($S$, $x$, $k$)</em> inserts the element $x$ with key $k$ into the set $S$</li>
  <li><em>EXTRACT-MIN($S$)</em> removes and returns the element of $S$ with the smallest key.</li>
  <li><em>DECREASE-KEY($S$, $x$, $k$)</em> decreases the value of element $x$’s key to the new value $k$, which is assumed to be at most as large as $x$’s current key value.</li>
</ul>

<p>The above notations are take from Cormen et al. [2].</p>

<h2 id="the-underlying-heap">The Underlying heap</h2>

<p>There are many possible implementations of this data structure. It is possible to base a priority queue on a linked list. However, when the network is rather sparse, using a priority queue based on a <em>heap</em> is more efficient. Several heap types can be used for a priority queue, for example Binary, Binomial or Fibonacci heaps. The Fibonacci heap has a better theoretical time complexity than the binary heap, but it is not so clear in practice : constant factors may differ a lot from one heap type to another. As explained by Delling et al. in [3]:</p>

<blockquote>
  <p>However, in practice the impact of priority queues on performance for large road networks is rather limited since cache faults for accessing the graph are usually the main bottleneck. In addition, our experiments indicate that the impact of priority queue implementations diminishes with advanced speedup techniques that dramatically reduce the queue sizes.</p>
</blockquote>

<p>It is also possible to exploit the property that the sequence of values returned by the EXTRACT-MIN calls in Dijkstra’s algorithm are monotonically increasing over time, as mentioned in [2]:</p>

<blockquote>
  <p>in this case several data structures can implement the various priority-queue operations more efficiently than a binary heap or a Fibonacci heap.</p>
</blockquote>

<p>In our implementation, we are going to keep the code as simple as possible and use the most rudimentary heap type: a binary heap, that does not take advantage of this monotone property. Note that we already used such a data structure, for the purpose of sorting, in previous posts:</p>
<ul>
  <li><a href="https://aetperf.github.io/2022/04/14/Heapsort-with-Numba-and-Cython.html">Heapsort with Numba and Cython</a></li>
  <li><a href="https://aetperf.github.io/2022/04/26/More-Heapsort-in-Cython.html">More Heapsort in Cython</a></li>
</ul>

<p>We refer to the <a href="https://aetperf.github.io/2022/04/14/Heapsort-with-Numba-and-Cython.html">first</a> of these two posts for a description of a binary heap.</p>

<h2 id="the-data-containers">The Data containers</h2>

<p>We base our implementation on an <em>implicit</em> approach, as described by Larkin et al. [4]:</p>

<blockquote>
  <p>The tree can be stored explicitly using heap-allocated nodes and pointers, or it can be encoded implicitly as a level-order traversal in an array. We refer to these variations as explicit and implicit heaps respectively. The implicit heap carries a small caveat, such that in order to support DecreaseKey efficiently, we must rely on a level of indirection: encoding the tree’s structure as an array of node pointers and storing the current index of a node’s pointer in the node itself […].</p>
</blockquote>

<p>So we are going to deal with two arrays:</p>
<ul>
  <li>an array of structs for the elements</li>
  <li>an array of indices for the binary tree</li>
</ul>

<p>The shortest path algorithm deals with a set of $n$ elements, e.g. $n=|V|$ where $V$ are the graph vertices. We store these elements in a first array:</p>

<p align="center">
  <img width="800" src="/img/2022-11-23_01/element_array_02.jpg" alt="element_array" />
</p>

<p>In a second array, we store an array-based binary tree:</p>

<p align="center">
  <img width="800" src="/img/2022-11-23_01/tree_array_03.jpg" alt="tree_array" />
</p>

<p>In the following, we denote by <code class="language-plaintext highlighter-rouge">A</code> the binary tree array and <code class="language-plaintext highlighter-rouge">Elements</code> the element array. <code class="language-plaintext highlighter-rouge">A</code> is an implicit data structure. Given a node index <code class="language-plaintext highlighter-rouge">i</code>, the parent node index can be easily found as <code class="language-plaintext highlighter-rouge">(i - 1) // 2</code>. The left child has index <code class="language-plaintext highlighter-rouge">2 * i + 1</code> and the right child <code class="language-plaintext highlighter-rouge">2 * (i + 1)</code>. The root is located at index 0.</p>

<h3 id="heap-length">Heap length</h3>

<p>The length of the tree array could be smaller than the element array because the heap size is usually much smaller that the total number of elements $n$, especially for sparse graphs. However, in the present post, we keep a tree array of the same length as the elements array, $n$, in order to guarantee that all the elements fit in the heap.</p>

<h3 id="mutual-references">Mutual references</h3>

<p>The path algorithm is only dealing with the elements, which are stored in the element array, and call the priority queue operations: insert, extract-min and decrease-key. The order of the elements in the element array is never changed, while items in the binary tree are permuted, in order to meet the min-heap property: a value of a given node <code class="language-plaintext highlighter-rouge">i</code> is not smaller than the value of its parent node <code class="language-plaintext highlighter-rouge">parent(i)</code>.</p>

<p>So we need some kind of mutual references, in order to associate an element in the heap to a tree node, and vice-versa. Since we have an array storing the elements, we are going to use indices to refer to the associated tree nodes. As Robert Sedgewick explains in [5]:</p>

<blockquote>
  <p>Suppose that the records to be processed in a priority queue are in an existing array. In this case, it makes sense to have the priority-queue routines refer to items through the array index. Moreover, we can use the array index as a handle to implement all the priority-queue operations.</p>
</blockquote>

<p>So there is a <code class="language-plaintext highlighter-rouge">node_idx</code> attribute in <code class="language-plaintext highlighter-rouge">Elements</code>, referring to some binary tree node. Conversely, we are also going to store the <code class="language-plaintext highlighter-rouge">element_idx</code> in <code class="language-plaintext highlighter-rouge">A</code>. The <code class="language-plaintext highlighter-rouge">key</code> value is stored in the <code class="language-plaintext highlighter-rouge">Element</code> array.</p>

<p align="center">
  <img width="1000" src="/img/2022-11-23_01/mutual_refs_01.jpg" alt="mutual_refs" />
</p>

<p>We have the following invariants:</p>

<p><code class="language-plaintext highlighter-rouge">Elements[A[i]].node_idx = i</code></p>

<p>and</p>

<p><code class="language-plaintext highlighter-rouge">A[Elements[i].node_idx] = i</code>.</p>

<p>And the min-heap property can be stated as follows:</p>

<p><code class="language-plaintext highlighter-rouge">Elements[A[parent(i)]].key &lt;= Elements[A[i]].key</code></p>

<h3 id="element-state">Element state</h3>

<p>One last thing is required: the element state. Since the heap size vary, elements may be or not in the heap. All the elements from the heap can be found in the <code class="language-plaintext highlighter-rouge">size</code> first elements of the tree array <code class="language-plaintext highlighter-rouge">A</code>: the <code class="language-plaintext highlighter-rouge">A[0]</code> to <code class="language-plaintext highlighter-rouge">A[size-1]</code> tree nodes correspond to elements in the heap, while the <code class="language-plaintext highlighter-rouge">A[size]</code> to <code class="language-plaintext highlighter-rouge">A[n]</code> tree nodes are not in the heap.</p>

<p>Path algorithms only deal with elements, not tree nodes, which belong to some kind of internal mechanism. There is a possibility that path algorithms, on the higher level, try to insert into the heap an element that was already popped from it. This is useless, since a shortest path may already exist for this element. So we need some kind of state flag to know if an element has already been scanned or not. We also use this state flag to check if an element is in the heap or not, which is more convenient than checking if the associated node index is smaller than the heap size. So we have 3 distinct states:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SCANNED</code></li>
  <li><code class="language-plaintext highlighter-rouge">NOT_IN_HEAP</code></li>
  <li><code class="language-plaintext highlighter-rouge">IN_HEAP</code></li>
</ul>

<p>Elements are initialized as <code class="language-plaintext highlighter-rouge">NOT_IN_HEAP</code>, with an inf key value and a <code class="language-plaintext highlighter-rouge">node_idx</code> equal to the heap length. The tree array is initialized with a <code class="language-plaintext highlighter-rouge">element_idx</code> also equal to the number of elements, which happens to be the heap length in our implementation.</p>

<p align="center">
  <img width="1000" src="/img/2022-11-23_01/mutual_refs_02.jpg" alt="mutual_refs" />
</p>

<h2 id="imports">Imports</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">load_ext</span> <span class="n">cython</span>
</code></pre></div></div>

<p>Package versions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Python version       : 3.10.7
cython               : 0.29.32
jupyterlab           : 3.5.0
numpy                : 1.23.5
</code></pre></div></div>

<h2 id="cython-code">Cython code</h2>

<p>Remarks:</p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">key</code> data type is defined as <code class="language-plaintext highlighter-rouge">float64</code></li>
  <li>We define an “infinity” as the maximum value that that can be store in the <code class="language-plaintext highlighter-rouge">key</code> data type. This is used to initialize the key value.</li>
  <li>We use an enumeration for the element state to associate the state name with an integer and make it easier to read</li>
  <li>Indices are defined as <code class="language-plaintext highlighter-rouge">size_t</code></li>
  <li>The GIL is released in all the functions</li>
  <li>This priority queue code can only be called from some Cython code</li>
  <li>We wrote a very small toy test at the end, that can be called from a Python cell</li>
</ul>

<div class="language-cython highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">cython</span> <span class="o">--</span><span class="nb">compile</span><span class="o">-</span><span class="n">args</span><span class="o">=-</span><span class="n">Ofast</span>
<span class="c1"># cython: language_level=3, boundscheck=False, wraparound=False, embedsignature=False, initializedcheck=False
# distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="kn">cimport</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">cnp</span>
<span class="kn">from</span> <span class="nn">libc.stdlib</span> <span class="kn">cimport</span> <span class="n">free</span><span class="p">,</span> <span class="n">malloc</span>

<span class="c1"># data type for the key value
</span><span class="k">ctypedef</span> <span class="n">cnp</span><span class="p">.</span><span class="n">float64_t</span> <span class="n">DTYPE_t</span>
<span class="k">cdef</span> <span class="kt">DTYPE_t</span> <span class="n">DTYPE_INF</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">DTYPE_t</span><span class="o">&gt;</span><span class="n">np</span><span class="p">.</span><span class="nf">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">).</span><span class="nb">max</span>

<span class="k">cdef</span> <span class="kr">enum</span> <span class="n">ElementState</span><span class="p">:</span>
   <span class="n">SCANNED</span>      <span class="c1"># popped from the heap
</span>   <span class="n">NOT_IN_HEAP</span>  <span class="c1"># never been in the heap
</span>   <span class="n">IN_HEAP</span>      <span class="c1"># in the heap
</span>
<span class="k">cdef</span> <span class="kr">struct</span> <span class="nc">Element</span><span class="p">:</span>
    <span class="kt">ElementState</span> <span class="n">state</span> <span class="c1"># element state wrt the heap
</span>    <span class="n">size_t</span> <span class="n">node_idx</span>   <span class="c1"># index of the corresponding node in the tree
</span>    <span class="n">DTYPE_t</span> <span class="n">key</span>        <span class="c1"># key value
</span>
<span class="k">cdef</span> <span class="kr">struct</span> <span class="nc">PriorityQueue</span><span class="p">:</span>
    <span class="kt">size_t</span>  <span class="n">length</span>    <span class="c1"># maximum heap size
</span>    <span class="n">size_t</span>  <span class="n">size</span>      <span class="c1"># number of elements in the heap
</span>    <span class="n">size_t</span><span class="o">*</span> <span class="n">A</span>         <span class="c1"># array storing the binary tree
</span>    <span class="n">Element</span><span class="o">*</span> <span class="n">Elements</span>  <span class="c1"># array storing the elements
</span>
<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">init_pqueue</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Initialize the priority queue.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    * size_t length : length (maximum size) of the heap
    </span><span class="sh">"""</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="n">i</span>

    <span class="n">pqueue</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">size_t</span><span class="o">*&gt;</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">size_t</span><span class="p">))</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">Element</span><span class="o">*&gt;</span> <span class="nf">malloc</span><span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">Element</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span>
        <span class="nf">_initialize_element</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_initialize_element</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">element_idx</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Initialize a single element.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    * size_t element_idx : index of the element in the element array
    </span><span class="sh">"""</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="n">DTYPE_INF</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">NOT_IN_HEAP</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">length</span>

<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">free_pqueue</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Free the priority queue.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    </span><span class="sh">"""</span>
    <span class="nf">free</span><span class="p">(</span><span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">)</span>
    <span class="nf">free</span><span class="p">(</span><span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">)</span>

<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">element_idx</span><span class="p">,</span>
    <span class="kt">DTYPE_t</span> <span class="n">key</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Insert an element into the priority queue and reorder the heap.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    * size_t element_idx : index of the element in the element array
    * DTYPE_t key : key value of the element

    assumptions
    ===========
    * the element pqueue.Elements[element_idx] is not in the heap
    * its new key is smaller than DTYPE_INF
    </span><span class="sh">"""</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="n">node_idx</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span>

    <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">IN_HEAP</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">node_idx</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">element_idx</span>
    <span class="nf">_decrease_key_from_node_index</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">decrease_key</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">element_idx</span><span class="p">,</span> 
    <span class="kt">DTYPE_t</span> <span class="n">key_new</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Decrease the key of a element in the priority queue, 
    given its element index.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    * size_t element_idx : index of the element in the element array
    * DTYPE_t key_new : new value of the element key 

    assumption
    ==========
    * pqueue.Elements[idx] is in the heap
    </span><span class="sh">"""</span>
    <span class="nf">_decrease_key_from_node_index</span><span class="p">(</span>
        <span class="n">pqueue</span><span class="p">,</span> 
        <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">node_idx</span><span class="p">,</span> 
        <span class="n">key_new</span><span class="p">)</span>

<span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">extract_min</span><span class="p">(</span><span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Extract element with min key from the priority queue, 
    and return its element index.

    input
    =====
    * PriorityQueue* pqueue : priority queue

    output
    ======
    * size_t : element index with min key

    assumption
    ==========
    * pqueue.size &gt; 0
    </span><span class="sh">"""</span>
    <span class="k">cdef</span><span class="p">:</span> 
        <span class="kt">size_t</span> <span class="n">element_idx</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># min element index
</span>        <span class="n">size_t</span> <span class="n">node_idx</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># last leaf node index
</span>
    <span class="c1"># exchange the root node with the last leaf node
</span>    <span class="nf">_exchange_nodes</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">)</span>

    <span class="c1"># remove this element from the heap
</span>    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCANNED</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_idx</span><span class="p">].</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">length</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">length</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># reorder the tree elements from the root node
</span>    <span class="nf">_min_heapify</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">element_idx</span>

<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_exchange_nodes</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">,</span> 
    <span class="kt">size_t</span> <span class="n">node_i</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">node_j</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Exchange two nodes in the heap.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    * size_t node_i: first node index
    * size_t node_j: second node index
    </span><span class="sh">"""</span>
    <span class="k">cdef</span><span class="p">:</span> 
        <span class="kt">size_t</span> <span class="n">element_i</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span>
        <span class="kt">size_t</span> <span class="n">element_j</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">node_j</span><span class="p">]</span>
    
    <span class="c1"># exchange element indices in the heap array
</span>    <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">node_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">element_j</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">node_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">element_i</span>

    <span class="c1"># exchange node indices in the element array
</span>    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_j</span><span class="p">].</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">node_i</span>
    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">element_i</span><span class="p">].</span><span class="n">node_idx</span> <span class="o">=</span> <span class="n">node_j</span>

    
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_min_heapify</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">node_idx</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Re-order sub-tree under a given node (given its node index) 
    until it satisfies the heap property.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    * size_t node_idx : node index
    </span><span class="sh">"""</span>
    <span class="k">cdef</span><span class="p">:</span> 
        <span class="kt">size_t</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">s</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

        <span class="n">l</span> <span class="o">=</span>  <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>  
        <span class="n">r</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="nf">if </span><span class="p">(</span>
            <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">and</span> 
            <span class="p">(</span><span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">key</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">l</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">i</span>

        <span class="nf">if </span><span class="p">(</span>
            <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">and</span> 
            <span class="p">(</span><span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">]].</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">s</span><span class="p">]].</span><span class="n">key</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="nf">_exchange_nodes</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">_decrease_key_from_node_index</span><span class="p">(</span>
    <span class="kt">PriorityQueue</span><span class="o">*</span> <span class="n">pqueue</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">node_idx</span><span class="p">,</span> 
    <span class="kt">DTYPE_t</span> <span class="n">key_new</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Decrease the key of an element in the priority queue, given its tree index.

    input
    =====
    * PriorityQueue* pqueue : priority queue
    * size_t node_idx : node index
    * DTYPE_t key_new : new key value

    assumptions
    ===========
    * pqueue.elements[pqueue.A[node_idx]] is in the heap (node_idx &lt; pqueue.size)
    * key_new &lt; pqueue.elements[pqueue.A[node_idx]].key
    </span><span class="sh">"""</span>
    <span class="k">cdef</span><span class="p">:</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">node_idx</span><span class="p">,</span> <span class="n">j</span>
        <span class="kt">DTYPE_t</span> <span class="n">key_j</span>

    <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">key</span> <span class="o">=</span> <span class="n">key_new</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>  
        <span class="n">key_j</span> <span class="o">=</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]].</span><span class="n">key</span>
        <span class="k">if</span> <span class="n">key_j</span> <span class="o">&gt;</span> <span class="n">key_new</span><span class="p">:</span>
            <span class="nf">_exchange_nodes</span><span class="p">(</span><span class="n">pqueue</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>


<span class="c1"># Simple example
# ==============
</span>
<span class="k">cpdef</span> <span class="nf">test_01</span><span class="p">():</span>

    <span class="k">cdef</span> <span class="kt">PriorityQueue</span> <span class="n">pqueue</span>

    <span class="nf">init_pqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
    <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
    <span class="nf">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span>
    <span class="n">A_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">n_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">key_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">A_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node_idx</span> <span class="o">==</span> <span class="n">n_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">==</span> <span class="n">IN_HEAP</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="n">key_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="nf">decrease_key</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span>
    <span class="n">A_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">n_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">key_ref</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">A_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node_idx</span> <span class="o">==</span> <span class="n">n_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">state</span> <span class="o">==</span> <span class="n">IN_HEAP</span>
        <span class="k">assert</span> <span class="n">pqueue</span><span class="p">.</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">==</span> <span class="n">key_ref</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="n">element_idx</span> <span class="o">=</span> <span class="nf">extract_min</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">element_idx</span> <span class="o">==</span> <span class="mi">3</span>

    <span class="nf">free_pqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pqueue</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">test_01</span><span class="p">()</span>
</code></pre></div></div>

<p>Everything seems to work fine. In a future post, we will use this priority queue in a shortest path algorithm, and try to measure its efficiency.</p>

<h2 id="references">References</h2>

<p>[1] Chen, M., <em>Measuring and Improving the Performance of Cache-efficient Priority Queues in Dijkstra’s Algorithm</em>, 2007. <br />
[2] Cormen et al., <em>Introduction to Algorithms</em>, MIT Press and McGraw-Hill, coll. « third », 2009.<br />
[3] Delling et al., <em>Engineering Route Planning Algorithms</em>. In: Lerner, J., Wagner, D., Zweig, K.A. (eds) Algorithmics of Large and Complex Networks. Lecture Notes in Computer Science, vol 5515. Springer, Berlin, Heidelberg, 2009. https://doi.org/10.1007/978-3-642-02094-0_7<br />
[4] Larkin et al., <em>A back-to-basics empirical study of priority queues</em>. In Proceedings of the 16th Workshop on Algorithm Engineering and Experiments (ALENEX), pages 61–72, 2014.<br />
[5] Robert Sedgewick. <em>Algorithms in C (3rd. ed.)</em>. Addison-Wesley Longman Publishing Co., Inc., USA, 2002.</p>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://aetperf-github-io-1.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

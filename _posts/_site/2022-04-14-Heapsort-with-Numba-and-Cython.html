<p><strong>Updated</strong> April 20, 2022 following usefull comments by <a href="https://github.com/scoder">@scoder</a>. Thank you very much for your pull requests!</p>

<p><em>Heapsort</em> is a classical sorting algorithm. We are going into a little bit of theory about the algorithm, but refer to Corman et al. [1] for more details, or the <a href="https://en.wikipedia.org/wiki/Heapsort">heapsort wikipedia page</a>.</p>

<p>In this post, we are going to implement the classical <em>heapsort</em> in Python, Python/Numba and Cython. The regular implementation is array-based and performed in-place. We use 0-based indices. Note that this is not a stable sorting method (keeping items with the same key in the  original order).</p>

<h2 id="imports">Imports</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">cycle</span>

<span class="kn">from</span> <span class="n">binarytree</span> <span class="kn">import</span> <span class="n">build</span>
<span class="kn">import</span> <span class="n">cython</span>
<span class="kn">from</span> <span class="n">numba</span> <span class="kn">import</span> <span class="n">njit</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">perfplot</span>
<span class="o">%</span><span class="n">load_ext</span> <span class="n">cython</span>

<span class="n">SD</span> <span class="o">=</span> <span class="mi">124</span>  <span class="c1"># random seed
</span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">default_rng</span><span class="p">(</span><span class="n">SD</span><span class="p">)</span>  <span class="c1"># random number generator
</span></code></pre></div></div>

<p>Language/package versions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Python implementation: CPython
Python version       : 3.9.12
IPython version      : 8.2.0
binarytree           : 6.5.1
matplotlib           : 3.5.1
perfplot             : 0.10.2
numpy                : 1.21.5
cython               : 0.29.28
numba                : 0.55.1
</code></pre></div></div>

<h2 id="float-array-creation">Float array creation</h2>

<p>We assume that we want to sort an NumPy array of 64-bit floating-point numbers :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="nf">random</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">A</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0.78525311, 0.78585936, 0.96913602, 0.74805977, 0.65555081,
       0.93888454, 0.17861445, 0.58864721, 0.44279917, 0.34884712])
</code></pre></div></div>

<h2 id="binary-trees">Binary trees</h2>

<p><em>Heapsort</em> is based on binary heap data structure, which relies on a nearly <a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">complete binary tree</a>:</p>

<blockquote>
  <p>a [nearly] complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.</p>
</blockquote>

<p>In a binary heap, the elements in an array are mapped to the tree nodes of a virtual binary tree. Assuming that we know the maximum number of elements in the heap, the array representation of the tree is more convenient than a linked structure. Note that it is also possible to use and array that can grow or shrink dynamically when threshold sizes are reached. Here is a figure showing the array elements and the corresponding tree nodes:</p>

<p align="center">
  <img width="800" src="/img/2022-04-14_01/bin-tree_3.png" alt="binary tree" />
</p>

<p>So we can see the array as a representation of the tree (implicit data structure): the node at the top (<code class="language-plaintext highlighter-rouge">A[0]</code>) of the tree is called the <strong>root</strong>, and the ones at the bottom, without children, are called the <strong>leaves</strong> (<code class="language-plaintext highlighter-rouge">A[5]</code>, <code class="language-plaintext highlighter-rouge">A[6]</code>, <code class="language-plaintext highlighter-rouge">A[7]</code>, <code class="language-plaintext highlighter-rouge">A[8]</code>, <code class="language-plaintext highlighter-rouge">A[9]</code>). An advantage of binary trees is that it is easy to navigate among the nodes. Tree node indexing goes from the root to the leaves and from left to right. Level $k\geq 0$ goes from node $2^k -1$ to node $2 (2^k -1)$. Within a level, you can go left by decrementing, and right by incrementing the node index by one. A node may have two children : the left and right ones. Given a node index <code class="language-plaintext highlighter-rouge">i</code>, the parent node index can be easily found as <code class="language-plaintext highlighter-rouge">(i - 1) // 2</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="nf">return </span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parent</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">parent</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3
</code></pre></div></div>

<p>The left child has index <code class="language-plaintext highlighter-rouge">2 * i + 1</code> and the right child <code class="language-plaintext highlighter-rouge">2 * (i + 1)</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">left_child</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">right_child</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">left_child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">right_child</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
</code></pre></div></div>

<p>The <strong>depth</strong> of a node is the number of edges from the root node to the target node. The <strong>height</strong> $h$ of a binary tree is the number of edges from the root to the most distant leaf node (in the above example, the height is equal to 3). We can bound the number of elements $n$ of the nearly complete tree using its height:</p>

\[2^h = \sum_{k=0}^{h-1} 2^k +1 \leq n \leq \sum_{k=0}^h 2^k = 2^{h+1}-1\]

<p>So that we have $h = \lfloor \log_2 n \rfloor $</p>

<h2 id="binary-heap">Binary heap</h2>

<p>Here is the definition of a heap [2]:</p>

<blockquote>
  <p>A heap is a set of nodes with keys arranged in a complete heap-ordered binary tree, represented as an array.</p>
</blockquote>

<p>A binary heap is binary tree data structure that satisfies a heap property. There are two kinds of heaps : min- and max-heaps satisfying respectively a min-heap or a max-heap property. In our case, we are going to use a max-heap to easily implement the <em>heapsort</em> algorithm. A min-heap would be used if sorting the array in a descending order, or would imply extra space/work to sort in ascending order.</p>

<p><strong>max-heap property</strong> : A value of a given node <code class="language-plaintext highlighter-rouge">i</code> is not larger than the value of its parent node <code class="language-plaintext highlighter-rouge">parent(i)</code></p>

\[A[parent(i)] \geq A[i]\]

<p>Thus value of the root node <code class="language-plaintext highlighter-rouge">A[0]</code> of a max-heap is greater than or equal to all the tree values. This is also true for any sub-tree of the binary heap: the root node of any sub-tree <code class="language-plaintext highlighter-rouge">A[i]</code> is greater than or equal to all the values in this sub-tree.</p>

<p>An important point is that not all the array elements might be in the heap. We differentiate the heap <code class="language-plaintext highlighter-rouge">size</code> from the array length $n$. We have $0 \leq size \leq n$. The element in heap are the <code class="language-plaintext highlighter-rouge">size</code> elements in the left part of the array: <code class="language-plaintext highlighter-rouge">A[0:size]</code> (with a Python slicing indexing). All remaining elements <code class="language-plaintext highlighter-rouge">A[size:n]</code> are not in the heap, implicitely.</p>

<p>Initially, given the above array <code class="language-plaintext highlighter-rouge">A</code>, it mostly likely does not satisfy the max-heap property, which would imply in our case:
<code class="language-plaintext highlighter-rouge">A[0] &gt;= A[1], A[0] &gt;= A[2], A[1] &gt;= A[3], A[1] &gt;= A[4], A[3] &gt;= A[7], A[3] &gt;= A[8 ], A[2] &gt;= A[5], A[2] &gt;= A[6]</code>. Indeed we have:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>False
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>False
</code></pre></div></div>

<p>We need to build the max-heap from an array by moving around the elements. In order to do that, we use a function called <code class="language-plaintext highlighter-rouge">max_heapify</code> from the leaves to the root of the tree, in a bottom-up manner. So let’s implement this function.</p>

<h2 id="max_heapify">Max_heapify</h2>

<p>The <code class="language-plaintext highlighter-rouge">max_heapify(A, size, i)</code> function presupposes that sub-trees rooted at the children nodes of <code class="language-plaintext highlighter-rouge">i</code> do satisfy the max-heap property. But the <code class="language-plaintext highlighter-rouge">i</code>-th node may violate it, i.e. <code class="language-plaintext highlighter-rouge">A[i] &lt; A[left_child(i)]</code> or <code class="language-plaintext highlighter-rouge">A[i] &lt; A[right_child(i)]</code>, assuming that the children are in the heap. If this is the case, the <code class="language-plaintext highlighter-rouge">i</code>-th node is swapped with its child with <code class="language-plaintext highlighter-rouge">largest</code> value:</p>
<pre><code class="language-Python">A[i], A[largest] = A[largest], A[i]
</code></pre>
<p>This process is then repeated from the largest children node. Eventually, the sub-tree rooted at <code class="language-plaintext highlighter-rouge">i</code> satisfies the max-heap property after a call to <code class="language-plaintext highlighter-rouge">max_heapify(A, size, i)</code>.</p>

<p>This process is also refered to as <strong>sift down</strong>: move a value violating the max-heap property down the tree by exchanging it with the largest of its 2 children values. Now it would also be possible to use the exact opposite process: <strong>sift up</strong>, which would start from a leaf node, and move its value up the tree by exchanging it with the parent node value, if violating the max-heap property. However, building a max-heap with the sift up process has a larger complexity than with sift down. I found this explanation by @alestanis on <a href="https://stackoverflow.com/a/13026026">Stack Overflow</a> really clear (The question was <strong>Why siftDown is better than siftUp in heapify?</strong>):</p>

<p align="center">
  <img width="800" src="/img/2022-04-14_01/sift-up.png" alt="Sift up" />
</p>

<p>So here is a Python implementation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">node_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="n">largest</span> <span class="o">=</span> <span class="n">node_idx</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nf">left_child</span><span class="p">(</span><span class="n">largest</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nf">right_child</span><span class="p">(</span><span class="n">largest</span><span class="p">)</span>

    <span class="nf">if </span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]):</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">l</span>

    <span class="nf">if </span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]):</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">node_idx</span><span class="p">:</span>
        <span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span>  <span class="c1"># exchange 2 nodes
</span>        <span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that this function is recursive. Let’s have a look at the tree values of our example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            ___________________0.78525___________
                           /                                     \
             __________0.78586___________                   ___0.96914___
            /                            \                 /             \
     ___0.74806__                   ___0.65555         0.93888         0.17861
    /            \                 /
0.58865         0.4428         0.34885
</code></pre></div></div>

<p>This array is random, but we can observe that the max-heap property is satisfied everywhere except at the root! The sub-trees rooted at nodes 1 and 2 do happen to satisfy the max-heap property already. So let’s call the <code class="language-plaintext highlighter-rouge">max_heapify</code> function on the root node.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">node_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            ___________________0.96914___________
                           /                                     \
             __________0.78586___________                   ___0.93888___
            /                            \                 /             \
     ___0.74806__                   ___0.65555         0.78525         0.17861
    /            \                 /
0.58865         0.4428         0.34885
</code></pre></div></div>

<p>The root node <code class="language-plaintext highlighter-rouge">A[0] = 0.78525</code> moved from node index 0 to 2, and then from 2 to 5. Nodes 2 and 5 moved one step up in the process.</p>

<p>Steps:</p>

<ul>
  <li>node 0 is compared with nodes 1 and 2. Node 0 is smaller than one of its children (0.78525 &lt; 0.96914). Node 2 is the child with largest value : exchange node 0 and 2.</li>
  <li>node 2 is compared with nodes 5 and 6. Node 0 is smaller than one of its children (0.78525 &lt; 0.93888). Node 5 is the child with largest value : exchange node 2 and 5.</li>
  <li>Node 5 is a leaf, so stop.</li>
</ul>

<p>Let’s generate a new random array to see another example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="nf">random</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">A</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0.3309295 , 0.15936868, 0.98946349, 0.25711078, 0.71576487,
       0.50588512, 0.66411132, 0.70234247, 0.05208023, 0.06009649])
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                             __________________0.33093___________
                            /                                    \
             ___________0.15937__________                   ___0.98946___
            /                            \                 /             \
     ___0.25711___                  ___0.71576         0.50589         0.66411
    /             \                /
0.70234         0.05208         0.0601
</code></pre></div></div>

<p>If we start from the leaves toward the root, we can notice a max-heap violation at node 3. So we call <code class="language-plaintext highlighter-rouge">max_heapify</code> on that node:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">node_idx</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                             __________________0.33093___________
                            /                                    \
             ___________0.15937__________                   ___0.98946___
            /                            \                 /             \
     ___0.70234___                  ___0.71576         0.50589         0.66411
    /             \                /
0.25711         0.05208         0.0601
</code></pre></div></div>

<p>Now let’s take care of node 1:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">node_idx</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                             __________________0.33093___________
                            /                                    \
             ___________0.71576__________                   ___0.98946___
            /                            \                 /             \
     ___0.70234___                  ___0.15937         0.50589         0.66411
    /             \                /
0.25711         0.05208         0.0601
</code></pre></div></div>

<p>And finally we need to fix the root value:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">node_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                             __________________0.98946___________
                            /                                    \
             ___________0.71576__________                   ___0.66411___
            /                            \                 /             \
     ___0.70234___                  ___0.15937         0.50589         0.33093
    /             \                /
0.25711         0.05208         0.0601
</code></pre></div></div>

<p>We actually built a max-heap manually. In the following let’s see the general method to build it.</p>

<h2 id="build_max_heap">Build_max_heap</h2>

<p>The method used to build the max-heap with a sift-down-based heapify is called <a href="https://en.wikipedia.org/wiki/Heapsort#Floyd's_heap_construction">Floyd’s heap construction</a>:</p>

<blockquote>
  <p>Floyd’s algorithm starts with the leaves, observing that they are trivial but valid heaps by themselves, and then adds parents. Starting with element n/2 and working backwards, each internal node is made the root of a valid heap by sifting down. The last step is sifting down the first element, after which the entire array obeys the heap property.</p>
</blockquote>

<p>This bottom-up heap construction technique runs in $O(n)$ time. Here is a Python implementation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">build_max_heap</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">node_idx</span> <span class="o">=</span> <span class="n">size</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># last non-leaf node index
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">node_idx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">node_idx</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">size</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="nf">random</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">A</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0.94535273, 0.25035043, 0.40579395, 0.27596342, 0.30065296,
       0.36667218, 0.14878984, 0.34834079, 0.59713033, 0.99416357])
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                             ___________________0.94535___________
                            /                                     \
             ___________0.25035___________                   ___0.40579___
            /                             \                 /             \
     ___0.27596___                   ___0.30065         0.36667         0.14879
    /             \                 /
0.34834         0.59713         0.99416
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span> <span class="o">=</span> <span class="nf">build_max_heap</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">tree_values</span> <span class="o">=</span> <span class="nf">build</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">tree_values</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                             ___________________0.99416___________
                            /                                     \
             ___________0.94535___________                   ___0.40579___
            /                             \                 /             \
     ___0.59713___                   ___0.30065         0.36667         0.14879
    /             \                 /
0.34834         0.27596         0.25035
</code></pre></div></div>

<h2 id="heapsort">Heapsort</h2>

<p>The classical <em>heapsort</em> has two steps:</p>

<p>1 - build the heap<br />
2 - destroy the heap by removing the root from the heap and moving it to the end of the heap $n$ times.</p>

<p>Step 2 corresponds to the following iterations:</p>
<ul>
  <li>swap the root (largest element) with the last leaf</li>
  <li>remove the last leaf from the heap.</li>
  <li>heapify the root on the reduced heap.</li>
</ul>

<p>The average and worst-case performance are $O(n\log n)$. Here is a Python implementation:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">A_in</span><span class="p">):</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">A_in</span><span class="p">)</span>

    <span class="c1"># build a max heap
</span>    <span class="n">size</span> <span class="o">=</span> <span class="nf">build_max_heap</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>

        <span class="c1"># swap the root (largest element) with the last leaf
</span>        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># removing largest element from the heap
</span>        <span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># call _max_heapify from the root on the heap with remaining elements
</span>        <span class="nf">max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">node_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="nf">random</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">A</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0.18525118, 0.99313433, 0.78561885, 0.44814329, 0.85044505,
       0.86088208, 0.96716993, 0.17096352, 0.69956773, 0.8288503 ])
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A_sorted_python</span> <span class="o">=</span> <span class="nf">heapsort</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">A_sorted_python</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0.17096352, 0.18525118, 0.44814329, 0.69956773, 0.78561885,
       0.8288503 , 0.85044505, 0.86088208, 0.96716993, 0.99313433])
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A_ref</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">np</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="nf">assert_array_equal</span><span class="p">(</span><span class="n">A_sorted_python</span><span class="p">,</span> <span class="n">A_ref</span><span class="p">)</span>
</code></pre></div></div>

<p>Let’s use Numba to make this Python code running fast.</p>

<h2 id="numba">Numba</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">max_heapify_numba</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">node_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="n">largest</span> <span class="o">=</span> <span class="n">node_idx</span>
    <span class="n">left_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">node_idx</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">node_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nf">if </span><span class="p">(</span><span class="n">left_child</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">left_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]):</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">left_child</span>

    <span class="nf">if </span><span class="p">(</span><span class="n">right_child</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">right_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]):</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">right_child</span>

    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">node_idx</span><span class="p">:</span>
        <span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span>  <span class="c1"># exchange 2 nodes
</span>        <span class="nf">max_heapify_numba</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">heapsort_numba</span><span class="p">(</span><span class="n">A_in</span><span class="p">):</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">A_in</span><span class="p">)</span>

    <span class="c1"># build a max heap
</span>    <span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">node_idx</span> <span class="o">=</span> <span class="n">size</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># last non-leaf node index
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">node_idx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">max_heapify_numba</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">node_idx</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># swap the root (largest element) with the last leaf
</span>        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># removing largest element from the heap
</span>        <span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># call _max_heapify from the root on the heap with remaining elements
</span>        <span class="nf">max_heapify_numba</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A_sorted_numba</span> <span class="o">=</span> <span class="nf">heapsort_numba</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">A_sorted_numba</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0.17096352, 0.18525118, 0.44814329, 0.69956773, 0.78561885,
       0.8288503 , 0.85044505, 0.86088208, 0.96716993, 0.99313433])
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="nf">assert_array_equal</span><span class="p">(</span><span class="n">A_sorted_numba</span><span class="p">,</span> <span class="n">A_ref</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="cython">Cython</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">cython</span> <span class="o">--</span><span class="nb">compile</span><span class="o">-</span><span class="n">args</span><span class="o">=-</span><span class="n">Ofast</span>

<span class="c1"># cython: boundscheck=False, initializedcheck=False, wraparound=False
</span>
<span class="kn">import</span> <span class="n">cython</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="kn">from</span> <span class="n">cython</span> <span class="kn">import</span> <span class="n">ssize_t</span><span class="p">,</span> <span class="n">double</span>


<span class="nd">@cython.exceptval</span><span class="p">(</span><span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython.nogil</span>
<span class="nd">@cython.cfunc</span>
<span class="k">def</span> <span class="nf">_max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">double</span><span class="p">[::</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">:</span> <span class="n">ssize_t</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">:</span> <span class="n">ssize_t</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">cython</span><span class="p">.</span><span class="n">void</span><span class="p">:</span>
    <span class="n">largest</span><span class="p">:</span> <span class="n">ssize_t</span> <span class="o">=</span> <span class="n">node_idx</span>

    <span class="n">left_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">node_idx</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right_child</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">node_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">left_child</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">left_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">left_child</span>

    <span class="k">if</span> <span class="n">right_child</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">A</span><span class="p">[</span><span class="n">right_child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">right_child</span>

    <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">node_idx</span><span class="p">:</span>
        <span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">largest</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span>
        <span class="nf">_max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>


<span class="nd">@cython.exceptval</span><span class="p">(</span><span class="n">check</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython.nogil</span>
<span class="nd">@cython.cfunc</span>
<span class="k">def</span> <span class="nf">_heapsort</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">double</span><span class="p">[::</span><span class="mi">1</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">cython</span><span class="p">.</span><span class="n">void</span><span class="p">:</span>
    <span class="n">i</span><span class="p">:</span> <span class="n">cython</span><span class="p">.</span><span class="nb">int</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">ssize_t</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">node_idx</span><span class="p">:</span> <span class="n">ssize_t</span> <span class="o">=</span> <span class="n">size</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">node_idx</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">_max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="nf">_max_heapify</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="nd">@cython.ccall</span>
<span class="k">def</span> <span class="nf">heapsort_cython</span><span class="p">(</span><span class="n">A_in</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">A_in</span><span class="p">)</span>
    <span class="nf">_heapsort</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A_sorted_cython</span> <span class="o">=</span> <span class="nf">heapsort_cython</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">A_sorted_cython</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([0.17096352, 0.18525118, 0.44814329, 0.69956773, 0.78561885,
       0.8288503 , 0.85044505, 0.86088208, 0.96716993, 0.99313433])
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="n">testing</span><span class="p">.</span><span class="nf">assert_array_equal</span><span class="p">(</span><span class="n">A_sorted_cython</span><span class="p">,</span> <span class="n">A_ref</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="performance-comparison">Performance comparison</h2>

<p>We do not include the Python version and compare the Numba and Cython versions with the NumPy <em>heapsort</em> implementation. It seems that this NumPy <em>heapsort</em> is written in C++ and is fairly well optimized.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">out</span> <span class="o">=</span> <span class="n">perfplot</span><span class="p">.</span><span class="nf">bench</span><span class="p">(</span>
    <span class="n">setup</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">rng</span><span class="p">.</span><span class="nf">random</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">),</span>
    <span class="n">kernels</span><span class="o">=</span><span class="p">[</span>
        <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="nf">heapsort_numba</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="nf">heapsort_cython</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
        <span class="k">lambda</span> <span class="n">A</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="sh">"</span><span class="s">heapsort</span><span class="sh">"</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">Numba</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">Cython</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">NumPy</span><span class="sh">"</span><span class="p">],</span>
    <span class="n">n_range</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)],</span>
<span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">out</span>
</code></pre></div></div>

<pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┓
┃<span style="font-weight: bold"> n         </span>┃<span style="font-weight: bold"> Numba               </span>┃<span style="font-weight: bold"> Cython                </span>┃<span style="font-weight: bold"> NumPy                  </span>┃
┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━┩
│ 10        │ 1.266e-06           │ 1.819e-06             │ 1.7500000000000002e-06 │
│ 100       │ 5.587e-06           │ 5.004000000000001e-06 │ 3.0430000000000003e-06 │
│ 1000      │ 0.000116266         │ 6.1561e-05            │ 6.2518e-05             │
│ 10000     │ 0.001819482         │ 0.0008792880000000001 │ 0.000939073            │
│ 100000    │ 0.028507956         │ 0.014659915           │ 0.013501216000000002   │
│ 1000000   │ 0.42401333100000005 │ 0.26564063200000004   │ 0.224838018            │
│ 10000000  │ 5.938197069         │ 5.285706523           │ 3.4547337810000003     │
│ 100000000 │ 78.544810064        │ 84.04674386900001     │ 49.002946636000004     │
└───────────┴─────────────────────┴───────────────────────┴────────────────────────┘
</pre>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>

<span class="n">labels</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="n">labels</span>
<span class="n">ms</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="p">.</span><span class="nf">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">loglog</span><span class="p">(</span>
    <span class="n">out</span><span class="p">.</span><span class="n">n_range</span><span class="p">,</span>
    <span class="n">out</span><span class="p">.</span><span class="n">n_range</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">n_range</span><span class="p">)</span> <span class="o">*</span> <span class="mf">5.0e-8</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">o-</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="sh">"</span><span class="s">$c \; n \; ln(n)$</span><span class="sh">"</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">loglog</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">n_range</span><span class="p">,</span> <span class="n">out</span><span class="p">.</span><span class="n">timings_s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="sh">"</span><span class="s">o-</span><span class="sh">"</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="n">ms</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
<span class="n">markers</span> <span class="o">=</span> <span class="nf">cycle</span><span class="p">((</span><span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">v</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">^</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">&lt;</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">&gt;</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">s</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">P</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">*</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">h</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">D</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">.</span><span class="sh">"</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">ax</span><span class="p">.</span><span class="nf">get_lines</span><span class="p">()):</span>
    <span class="n">marker</span> <span class="o">=</span> <span class="nf">next</span><span class="p">(</span><span class="n">markers</span><span class="p">)</span>
    <span class="n">line</span><span class="p">.</span><span class="nf">set_marker</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="sh">"</span><span class="s">on</span><span class="sh">"</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span>
    <span class="n">title</span><span class="o">=</span><span class="sh">"</span><span class="s">Timing comparison between Numba, Cython and NumPy heapsort</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">xlabel</span><span class="o">=</span><span class="sh">"</span><span class="s">Array length (log scale)</span><span class="sh">"</span><span class="p">,</span>
    <span class="n">ylabel</span><span class="o">=</span><span class="sh">"</span><span class="s">Elapsed_time [s] (log scale)</span><span class="sh">"</span><span class="p">,</span>
<span class="p">)</span>
</code></pre></div></div>

<p align="center">
  <img width="800" src="/img/2022-04-14_01/output_54_0.png" alt="Timings" />
</p>

<h2 id="conclusion">Conclusion</h2>

<p>Going from Python to Numba is seamless and is allowing us to reach a similar level of efficiency as with Cython (that turned 20 years old last week, happy birthday!!). We can observe that the NumPy <em>heapsort</em> implementation is faster on larger arrays, but we do not know which optimizations did they implement.</p>

<h2 id="references">References</h2>

<p>[1] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. 2009. Introduction to Algorithms, Third Edition (3rd. ed.). The MIT Press.</p>

<p>[2] Robert Sedgewick. 2002. Algorithms in C (3rd. ed.). Addison-Wesley Longman Publishing Co., Inc., USA.</p>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://aetperf-github-io-1.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

